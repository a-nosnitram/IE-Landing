<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eyes That Open</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: radial-gradient(
          ellipse at center,
          #1a0033 0%,
          #000000 100%
        );
        min-height: 100vh;
        overflow: hidden;
        position: relative;
      }

      /* Animated starfield background */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: radial-gradient(
            2px 2px at 20% 30%,
            white,
            transparent
          ),
          radial-gradient(2px 2px at 60% 70%, white, transparent),
          radial-gradient(1px 1px at 50% 50%, white, transparent),
          radial-gradient(1px 1px at 80% 10%, white, transparent),
          radial-gradient(2px 2px at 90% 60%, white, transparent),
          radial-gradient(1px 1px at 33% 85%, white, transparent),
          radial-gradient(2px 2px at 70% 40%, white, transparent);
        background-size: 200% 200%;
        background-position: 0% 0%;
        animation: stars 200s linear infinite;
        opacity: 0.5;
        pointer-events: none;
        z-index: 0;
      }

      @keyframes stars {
        0% {
          background-position: 0% 0%;
        }
        100% {
          background-position: 200% 200%;
        }
      }

      /* Floating particles */
      .particle {
        position: fixed;
        border-radius: 50%;
        pointer-events: none;
        opacity: 0.6;
        z-index: 0;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0) translateX(0);
        }
        25% {
          transform: translateY(-30px) translateX(15px);
        }
        50% {
          transform: translateY(-10px) translateX(-10px);
        }
        75% {
          transform: translateY(-40px) translateX(5px);
        }
      }

      /* Gradient overlay to blend eyes with background */
      .gradient-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
        background: radial-gradient(
            circle at 50% 50%,
            transparent 0%,
            rgba(0, 0, 0, 0.3) 100%
          ),
          radial-gradient(
            ellipse at 20% 30%,
            rgba(26, 0, 51, 0.4) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 80% 70%,
            rgba(26, 0, 51, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse at 40% 80%,
            rgba(13, 0, 26, 0.5) 0%,
            transparent 40%
          ),
          radial-gradient(
            ellipse at 70% 20%,
            rgba(13, 0, 26, 0.4) 0%,
            transparent 45%
          );
        mix-blend-mode: normal;
      }

      /* Vignette effect */
      .gradient-overlay::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at center,
          transparent 0%,
          transparent 40%,
          rgba(0, 0, 0, 0.5) 70%,
          rgba(0, 0, 0, 0.8) 100%
        );
      }

      /* Subtle cosmic dust overlay */
      .gradient-overlay::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: radial-gradient(
            circle at 15% 25%,
            rgba(138, 43, 226, 0.15) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 85% 75%,
            rgba(75, 0, 130, 0.15) 0%,
            transparent 25%
          ),
          radial-gradient(
            circle at 50% 60%,
            rgba(72, 61, 139, 0.1) 0%,
            transparent 30%
          ),
          radial-gradient(
            circle at 30% 90%,
            rgba(138, 43, 226, 0.12) 0%,
            transparent 22%
          );
        mix-blend-mode: screen;
        opacity: 0.6;
      }

      @keyframes glow {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 0.8;
        }
      }

      /* Cosmic cursor light */
      .cursor-light {
        position: fixed;
        pointer-events: none;
        z-index: 9998;
        width: 300px;
        height: 300px;
        transform: translate(-50%, -50%);
        transition: opacity 0.3s ease;
        opacity: 0;
      }

      .cursor-light::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle at center,
          rgba(138, 43, 226, 0.4) 0%,
          rgba(147, 51, 234, 0.3) 20%,
          rgba(168, 85, 247, 0.2) 40%,
          transparent 70%
        );
        filter: blur(20px);
        animation: pulseLight 3s ease-in-out infinite;
      }

      .cursor-light::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150%;
        height: 150%;
        background: radial-gradient(
          circle at center,
          rgba(255, 255, 255, 0.15) 0%,
          rgba(138, 43, 226, 0.1) 30%,
          transparent 60%
        );
        filter: blur(40px);
        mix-blend-mode: screen;
      }

      @keyframes pulseLight {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0.8;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.1);
          opacity: 1;
        }
      }

      .eye {
        position: absolute;
        width: 20px;
        height: 20px;
        cursor: pointer;
        transition: transform 0.3s ease;
        z-index: 1;
        will-change: transform;
        contain: layout style paint;
        transform: translateZ(0);
      }

      .eye:hover {
        transform: scale(1.1);
      }

      .eye-outer {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .eye-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .eyeball {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        height: 60%;
        background: white;
        border-radius: 50%;
        overflow: visible;
        box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.2);
      }

      .mask-top,
      .mask-bottom {
        transition: transform 0.3s ease-in-out;
        transform-origin: center;
        will-change: transform;
      }

      .eye.open .mask-top {
        transform: translateY(-100px);
      }

      .eye.open .mask-bottom {
        transform: translateY(100px);
      }

      .iris {
        transition: transform 0.2s ease-out !important;
        will-change: transform;
        backface-visibility: hidden;
      }

      /* Blink animation with its own timing */
      @keyframes blinkTop {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-40px);
        }
      }

      @keyframes blinkBottom {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(40px);
        }
      }

      .eye.blinking .mask-top {
        animation: blinkTop 10s ease-in-out forwards;
      }

      .eye.blinking .mask-bottom {
        animation: blinkBottom 10s ease-in-out forwards;
      }
      .iris {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate3d(-50%, -50%, 0);
        width: 70%;
        height: 70%;
        border-radius: 50%;
        transition: transform 0.08s ease-out;
      }

      .iris::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 50%;
        height: 100%;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.3) 0%,
          transparent 50%
        );
      }

      .pupil {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 40%;
        height: 40%;
        background: #000;
        border-radius: 50%;
      }

      .pupil::after {
        content: "";
        position: absolute;
        top: 20%;
        left: 25%;
        width: 30%;
        height: 30%;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
      }

      /* Different eye colors */
      .color-hazel {
        background: radial-gradient(circle, #b8860b 0%, #8b6914 70%);
      }
    </style>
  </head>
  <body>
    <!-- Cosmic cursor light that follows the mouse -->
    <div class="cursor-light" id="cursorLight"></div>

    <!-- Gradient overlay to blend eyes with cosmic background -->
    <div class="gradient-overlay"></div>

    <script>
      // Create floating cosmic particles
      function createParticles() {
        const particleCount = 50;
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";

          // Random size between 1-4px
          const size = Math.random() * 3 + 1;
          particle.style.width = size + "px";
          particle.style.height = size + "px";

          // Random position
          particle.style.left = Math.random() * 100 + "%";
          particle.style.top = Math.random() * 100 + "%";

          // Random colors - purple, blue, pink hues
          const colors = [
            "#8b5cf6",
            "#6366f1",
            "#ec4899",
            "#a855f7",
            "#3b82f6",
          ];
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];
          particle.style.boxShadow = `0 0 ${size * 2}px ${
            particle.style.background
          }`;

          // Random animation duration
          const duration = 10 + Math.random() * 20;
          particle.style.animation = `float ${duration}s ease-in-out infinite, glow ${
            3 + Math.random() * 4
          }s ease-in-out infinite`;
          particle.style.animationDelay = `${Math.random() * 5}s`;

          document.body.appendChild(particle);
        }
      }

      // Create particles on load
      createParticles();

      // Generate random eye colors
      const colors = ["color-hazel"];

      // Generate eyes in a grid pattern with random rotation and positioning
      const spacing = 40;
      const offsetX = 10;
      const offsetY = 10;

      // Create multiple eyes across the page
      function createEye(x, y) {
        const eye = document.createElement("div");
        eye.className = "eye";
        eye.style.left = x + "px";
        eye.style.top = y + "px";

        // Add random size (between 60% and 140% of base 20px size)
        const randomSize = 0.6 + Math.random() * 0.8;
        const sizeInPx = 20 * randomSize;
        eye.style.width = sizeInPx + "px";
        eye.style.height = sizeInPx + "px";

        // Add random rotation
        const randomRotation = Math.random() * 360;
        eye.style.transform = `rotate(${randomRotation}deg)`;

        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        const uniqueId = `${Date.now()}-${Math.random()
          .toString(36)
          .substr(2, 9)}`;

        eye.innerHTML = `
                <div class="eye-outer">
                    <svg class="eye-svg" viewBox="0 0 100 100" preserveAspectRatio="none" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;">
                        <defs>
                            <mask id="eyelid-mask-${uniqueId}">
                                <rect width="100" height="100" fill="white"/>
                                <path class="mask-top" d="M 0,0 L 0,80 Q 25,65 50,60 Q 75,65 100,80 L 100,0 Z" fill="black"/>
                                <path class="mask-bottom" d="M 0,100 L 0,20 Q 25,35 50,40 Q 75,35 100,20 L 100,100 Z" fill="black"/>
                            </mask>
                        </defs>
                        <g mask="url(#eyelid-mask-${uniqueId})">
                            <ellipse cx="50" cy="50" rx="45" ry="30" fill="white"/>
                            <foreignObject x="5" y="20" width="90" height="60">
                                <div xmlns="http://www.w3.org/1999/xhtml" style="width: 100%; height: 100%; position: relative;">
                                    <div class="iris ${randomColor}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 50%; height: 70%; border-radius: 50%;">
                                        <div class="pupil"></div>
                                    </div>
                                </div>
                            </foreignObject>
                        </g>
                    </svg>
                </div>
            `;

        document.body.appendChild(eye);

        return eye;
      }

      // Track all eyes and their positions
      const eyes = [];
      const openRadius = 70; // Distance in pixels for eye to open
      const closeRadius = 20; // Distance at which to start closing
      let animationFrame;
      let lastMouseX = 0;
      let lastMouseY = 0;

      // Blink settings (adjustable)
      const BLINK_DURATION = 10000; // How long the blink lasts in ms (match animation duration)
      const BLINK_FREQUENCY_MIN = 70000; // Minimum time between blinks in ms
      const BLINK_FREQUENCY_MAX = 100000; // Maximum time between blinks in ms

      // Make an eye blink
      function blinkEye(eyeData) {
        const eye = eyeData.element;

        // Don't blink if eye is currently open from mouse hover
        if (eye.classList.contains("open") || eyeData.isOpen) {
          scheduleNextBlink(eyeData);
          return;
        }

        // Remove class first if it exists (to allow re-triggering)
        eye.classList.remove("blinking");

        // Force a reflow to restart the animation
        void eye.offsetWidth;

        // Trigger CSS animation
        eye.classList.add("blinking");

        // Remove class after animation completes
        setTimeout(() => {
          eye.classList.remove("blinking");
          scheduleNextBlink(eyeData);
        }, BLINK_DURATION);
      }

      // Schedule the next blink with random timing
      function scheduleNextBlink(eyeData) {
        const nextBlinkTime =
          BLINK_FREQUENCY_MIN +
          Math.random() * (BLINK_FREQUENCY_MAX - BLINK_FREQUENCY_MIN);
        eyeData.blinkTimeout = setTimeout(
          () => blinkEye(eyeData),
          nextBlinkTime
        );
      }

      // Intersection Observer to only animate visible eyes
      const visibleEyes = new Set();
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            const eyeData = eyes.find((e) => e.element === entry.target);
            if (eyeData) {
              if (entry.isIntersecting) {
                visibleEyes.add(eyeData);
              } else {
                visibleEyes.delete(eyeData);
              }
            }
          });
        },
        { rootMargin: "50px" }
      );

      // Check distance and open/close eyes based on mouse position
      // Only update visible eyes for performance
      function updateEyes(mouseX, mouseY) {
        visibleEyes.forEach((eyeData) => {
          const eye = eyeData.element;

          // Use cached position if available, update occasionally
          if (!eyeData.cachedRect || Math.random() < 0.1) {
            eyeData.cachedRect = eye.getBoundingClientRect();
          }

          const eyeRect = eyeData.cachedRect;
          const eyeCenterX = eyeRect.left + eyeRect.width / 2;
          const eyeCenterY = eyeRect.top + eyeRect.height / 2;

          const dx = mouseX - eyeCenterX;
          const dy = mouseY - eyeCenterY;
          const distanceSq = dx * dx + dy * dy;
          const distance = Math.sqrt(distanceSq);

          if (distance < openRadius) {
            if (!eyeData.isOpen) {
              clearTimeout(eyeData.closeTimeout);
              eye.classList.add("open");
              eyeData.isOpen = true;
              // Cache iris element
              if (!eyeData.irisElement) {
                eyeData.irisElement = eye.querySelector(".iris");
              }
            }

            // Move iris to follow mouse - constrained within eye boundaries
            const iris = eyeData.irisElement;
            if (iris) {
              const angle = Math.atan2(dy, dx);
              const maxMove = 3;
              const irisDistance = Math.min(maxMove, distance * 0.066);

              const irisX = Math.cos(angle) * irisDistance;
              const irisY = Math.sin(angle) * irisDistance;

              // Use translate3d for hardware acceleration
              iris.style.transform = `translate3d(${
                -50 + (irisX / eyeRect.width) * 100
              }%, ${-50 + (irisY / eyeRect.height) * 100}%, 0)`;
            }
          } else if (distance > closeRadius && eyeData.isOpen) {
            if (!eyeData.closeTimeout) {
              const iris = eyeData.irisElement;
              if (iris) {
                iris.style.transform = "translate3d(-50%, -50%, 0)";
              }

              const closeDelay = Math.min(200, (distance - closeRadius) * 2);
              eyeData.closeTimeout = setTimeout(() => {
                eye.classList.remove("open");
                eyeData.isOpen = false;
                eyeData.closeTimeout = null;
              }, closeDelay);
            }
          } else if (
            distance >= openRadius &&
            distance <= closeRadius &&
            eyeData.closeTimeout
          ) {
            clearTimeout(eyeData.closeTimeout);
            eyeData.closeTimeout = null;
          }
        });
      }

      // Cosmic cursor light
      const cursorLight = document.getElementById("cursorLight");
      let cursorLightVisible = false;

      // Smooth mouse tracking with velocity limiting
      let smoothMouseX = 0;
      let smoothMouseY = 0;
      let lastUpdateTime = Date.now();
      const MAX_MOUSE_VELOCITY = 5000; // pixels per second - skip if exceeded
      const SMOOTHING_FACTOR = 0.7; // Lower = smoother but more lag, higher = more responsive

      // Track mouse movement with smoothing and velocity check
      document.addEventListener("mousemove", (e) => {
        const targetX = e.clientX;
        const targetY = e.clientY;
        const now = Date.now();
        const deltaTime = (now - lastUpdateTime) / 1000; // seconds

        // Update cursor light position
        cursorLight.style.left = targetX + "px";
        cursorLight.style.top = targetY + "px";

        // Show cursor light on first movement
        if (!cursorLightVisible) {
          cursorLight.style.opacity = "1";
          cursorLightVisible = true;
        }

        // Calculate mouse velocity
        const dx = targetX - lastMouseX;
        const dy = targetY - lastMouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const velocity = distance / deltaTime;

        lastMouseX = targetX;
        lastMouseY = targetY;
        lastUpdateTime = now;

        // Skip animation if mouse is moving too fast
        if (velocity > MAX_MOUSE_VELOCITY) {
          return;
        }

        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }

        animationFrame = requestAnimationFrame(() => {
          // Smooth interpolation towards target position
          smoothMouseX += (targetX - smoothMouseX) * SMOOTHING_FACTOR;
          smoothMouseY += (targetY - smoothMouseY) * SMOOTHING_FACTOR;

          updateEyes(smoothMouseX, smoothMouseY);
        });
      });

      // Generate eyes and store references
      for (let y = offsetY; y < window.innerHeight + spacing; y += spacing) {
        for (let x = offsetX; x < window.innerWidth + spacing; x += spacing) {
          const randomX = x + (Math.random() - 0.5) * 20;
          const randomY = y + (Math.random() - 0.5) * 20;
          const eye = createEye(randomX, randomY);
          const eyeData = {
            element: eye,
            closeTimeout: null,
            isOpen: false,
            blinkTimeout: null,
          };
          eyes.push(eyeData);

          // Observe eye for visibility tracking
          observer.observe(eye);

          // Schedule first blink with random delay
          const initialDelay = Math.random() * BLINK_FREQUENCY_MAX;
          eyeData.blinkTimeout = setTimeout(
            () => blinkEye(eyeData),
            initialDelay
          );
        }
      } // Add more eyes on window resize
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          document.querySelectorAll(".eye").forEach((eye) => eye.remove());
          // Clear all timeouts and unobserve
          eyes.forEach((eyeData) => {
            clearTimeout(eyeData.closeTimeout);
            clearTimeout(eyeData.blinkTimeout);
            observer.unobserve(eyeData.element);
          });
          eyes.length = 0;
          visibleEyes.clear();
          for (
            let y = offsetY;
            y < window.innerHeight + spacing;
            y += spacing
          ) {
            for (
              let x = offsetX;
              x < window.innerWidth + spacing;
              x += spacing
            ) {
              const randomX = x + (Math.random() - 0.5) * 20;
              const randomY = y + (Math.random() - 0.5) * 20;
              const eye = createEye(randomX, randomY);
              const eyeData = {
                element: eye,
                closeTimeout: null,
                isOpen: false,
                blinkTimeout: null,
              };
              eyes.push(eyeData);

              // Observe eye for visibility tracking
              observer.observe(eye);

              // Schedule first blink with random delay
              const initialDelay = Math.random() * BLINK_FREQUENCY_MAX;
              eyeData.blinkTimeout = setTimeout(
                () => blinkEye(eyeData),
                initialDelay
              );
            }
          }
        }, 250);
      });
    </script>
  </body>
</html>
